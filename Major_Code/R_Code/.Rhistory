###############################  further updated versions: ####
# not used in manuscript, but improved coding. nevertheless these functions
# lead to the same results as the above functions
RW_CLS <- function(Data, response_, w = 0, R = 100,
bagging = F, abs_cls = T, pr = T){
n = nrow(Data)
p = ncol(Data)
# window width:
if(w==0){
w = n+1
} else{w = w}
A <- numeric(0)  # control if we catch all SNPs
# loop:
SNPs = colnames(Data)
cls = data.frame('SNP' = rep(NA, p), 'Score' = rep(NA, p))
i = 0
while (length(A) < p & i < R) { # break if R is reached or all variables are chosen
# at least once
s = sample(1:p, w)  # sample w SNPs in each step independently
A <- c(A, s) %>% unique() # count how many different SNPs we consider
if(pr == T){i = i+1
print(i)
pp = paste((100*length(A))/p, '%')
print(pp)}
# bagging yes or no:
if(bagging == TRUE){
n_ <- sample(1:n, n, TRUE)
} else{n_ = 1:n}
# construct window, contains of w SNPs and response y:
XY_ = cbind(Data[n_ ,s], response_[n_])
# calc all scores for the subset:
levs_ = getCLS(XY_)
if(abs_cls == T){ # abs or not?
levs_ <- abs(levs_)
} else{levs_ <- levs_}
cls <- cbind(cls, 0)
cls[s,3] <- levs_
cls$SNP[s] <- SNPs[s]
cls$Score[s] = apply(cls[s,2:3], 1, function(x) min(x, na.rm = T))
cls <- cls[,-3]
}
return(cls)
}
